---
title: "2. mapview advanced controls"
output:
  rmarkdown::html_document:
    toc: true
    theme: united
vignette: >
  %\VignetteIndexEntry{2. mapview advanced controls}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo=FALSE}
knitr::opts_chunk$set(fig.width = 8.83)
```
------

Despite the possibility to quickly plot spatial data, `mapview` has a set of arguments for finer control of the visualization. Depending on the object class, these are:

**All types**

* `map` - the **leaflet** or **mapview** map to use -> default NULL
* `col.regions` - the color palette for colouring raster, polygon and point areas (points are essentially circles) -> default `viridisLite::inferno` for raster data and `viridisLite::viridis` for vector data
* `at` - breakpoints used for the colouring -> default NULL meaning they are calculated automatically for the range of data
* `na.color` - the color for NA values -> default `#BEBEBE80`
* `map.types` - the types of the background maps -> default ```r mapview::mapviewGetOption("basemaps")``` see [here](http://leaflet-extras.github.io/leaflet-providers/preview/) for available map types
* `alpha.regions` - the opacity of raster, polygon and point fills -> default `0.8` for raster, `0.6` for polygons and `0.9` for points
* `legend` - whether to add a legend to the plot -> default `FALSE`
* `legend.opacity` - opacity of the legend -> default `1`
* `verbose` - whether to print additional information to the console during the rendering -> default `FALSE`
* `layer.name` - the layer name to be used for plotting -> default depends on call. For a single object the name of the object; if `zcol` is supplied a combination of object name and column name; for raster stack/bricks the layer names
* ... - further arguments to be passed on to respective **leaflet** functions such as `addRasterImage` or `adCircleMarkers`

**raster only**

* `maxpixels` - the maximum number of pixels to plot -> default 500k. This is used so rendering doesn't take forever. This can also be set with `mapviewOptions()`
* `use.layer.names` - whether to use the layer names of raster objects -> default `FALSE`
* `trim` - should rasters be trimmed off NA values around the edges -> default `TRUE`

**vector only**

* `zcol` - attribute name(s) or column number(s) in attribute table of the column(s) to be rendered -> default `NULL` 
* `burst` - whether to show all (TRUE) or only one (FALSE) layer(s) -> default `FALSE`
* `color` - color (palette) for lines -> default `viridisLite::viridis`
* `alpha` - opacity of the lines -> default `0.9`
* `cex` - circle size for point data -> default `6`. This can also be used to map circle size to an attribute from the object's attribute table by supplying either column name or number
* `lwd` - line width -> default `2` for lines and points, `1` for polygons
* `label` - a character vector of labels to be shown on mouseover -> default feature IDs, if `zcol` is set the values of `zcol`
* `popup` - the popup function to use for the popups -> default `popupTable()`. See chapter on popups for further options

------

Here's a few examples of how selected arguments can be used:

## col.regions & at

Similar to the good old `spplot`, arguments `col.regions` and `at` can be used for finer control of the colouring

```{r kili col.regions at, message = FALSE}
library(mapview)
library(raster)
library(RColorBrewer)

pal <- colorRampPalette(brewer.pal(9, "BrBG"))

kili_data <- system.file("extdata", "kiliNDVI.tif", package = "mapview")
kiliNDVI <- stack(kili_data)

mapview(kiliNDVI[[1]], col.regions = pal(100), at = seq(-0.2, 1, 0.2), legend = TRUE)
```


```{r breweries col.regions at, message = FALSE}
mapview(breweries, zcol = "founded", at = seq(1400, 2200, 200), legend = TRUE)
```

------

## map.types

To use a different background map, use argument `map.types`

```{r breweries map.types, message = FALSE}
mapview(breweries, map.types = c("Esri.WorldShadedRelief", "OpenStreetMap.DE"), color = "grey40")
```

------

## layer.name

To individually label the layer names use argument `layer.name`

```{r meuse layer.name, message = FALSE}
mapview(list(franconia, breweries),
        layer.name = c("Franconian districts", "Franconian breweries"))
```

------

## burst

`burst` can be used to plot all layers of an object

```{r brew burst, message = FALSE}
mapview(breweries, burst = TRUE)
```

Note how all layers are shown by default. There is a hidden argument `hide` which can be used to hide all layers but the first.

```{r brew burst hide, message = FALSE}
mapview(breweries, burst = TRUE, hide = TRUE)
```

When `burst` used together with `zcol`, it will produce one layer for all unique values of `zcol`. 

```{r brew district burst, message = FALSE}
library(dplyr)
library(sf)

breweries %>%
  st_intersection(franconia) %>%
  mapview(zcol = "district", burst = TRUE)
```

Note that for a column with many values there will likely not be enough space for the layers control - we are working on a solution for this issue.

------

## cex

For point data the circle size can be mapped to one of the attributes (features with NA values will be shown as dots)

```{r breweries cex types, message = FALSE}
mapview(breweries, cex = "number.of.types")
```

------
